%!PS-Adobe-3.0
%%Title: Electronic Schematic Elements
%%Creator: Daren Scot Wilson
%%Pages: 1


% General notes:
%
% In arguments, the notation (x,y) means two argument, with y on top,
% that represent a point's location.
%
% This file is all hand-written.  The first part is general 
% electronics, and the last part draws the schematic for
% the project
%




% for debugging...

/redmarker 
{
	gsave
	1 setlinewidth
	1 0 .5 setrgbcolor
	newpath 8 0 360 arc stroke
	grestore
} def


/bluemarker 
{
	gsave
	1 setlinewidth
	0 0 .8 setrgbcolor
	newpath 8 0 360 arc stroke
	grestore
} def






%------------------------------- SCALING ------------------




% coords: the usual PS units

/inch   { 72.0 mul } def


% redefine "inch" as "pinch" = part inch,
% used to specify sizes of part symbols.
% change this definition to rescale all the part sizes
% without messing up the scale of the overall drawing
%
/pinch  { 72.0 .6 mul mul } bind def





% ------------------- Utility routines ----------------

% CopyXX and CopyYY prepare a copy of the x or the y coords on the stack
% while preserving the original two points
% Note:  A vector (x,y) is stored on the stack with y on top
%
% Args:
% 	(x2,y2)
% 	(x1,y1)
%
% Output for CopyXX:  
% 	x2
% 	x1
% 	(x2,y2)
% 	(x1,y1)
%
% Output for CopyYY:  
% 	y2
% 	y1
% 	(x2,y2)
% 	(x1,y1)

/CopyXX
	{
	3 index
	2 index
	}
		bind def
		
/CopyYY
	{
	2 index
	1 index
	}
		bind def


% Compute midpoint, given two points
%
% args
%		(x2,y2)
%		(x1,y1)
%
% output
%		(xm,ym)
%
/MidPoint  
	{
	3 -1 roll  add 2 div
	3 1  roll  add 2 div 
	exch
	}
		bind def


% SwapPts exchanges two points
/SwapPts
	{
	4 2 roll
	}
		bind def




% Shrink a line segment, reducing both ends by a given distance
%
% args:
% 		D             amount of distance to remove from each end
%		(x2,y2)       any point P1
%		(x1,y1)       any other point P1
%
% results
%		true          went ok
% 		(x2',y2')     modified point P1
% 		(x1',y1')     modified point P1
% or
%		false         original seg was too short
%
/ShrinkSeg
	{
	/D  exch def
	/y2 exch def
	/x2 exch def
	/y1 exch def
	/x1 exch def
	
	/dx   x2 x1 sub  cvr def
	/dy   y2 y1 sub  cvr def
	% renormalize vector to length = D
	D                                      % length to chop per end
	dx dx  mul   dy dy  mul  add  sqrt     % given seg's length
	div
	% test if seg is so short it'll disappear
	dup .5 lt
		{
		dup 
		dy mul  /dy exch def      % redef dy as change in end point
		dx mul  /dx exch def


		% Deposit the new end points, nudging coords as we go along
		x1 dx add
		y1 dy add
		x2 dx sub
		y2 dy sub
		true
		}
		{
		pop   % remove the shrink proportion, used only in the THEN clause
		false
		}
	ifelse
	}
		bind def



% largest and smallest are like max, min in most languages
%
% args:
%		x1 x2
%
% output:
%		x       - the largest or smallest of the two inputs

/smallest  { 2 copy gt { exch } if pop } def
/largest   { 2 copy lt { exch } if pop } def




% Make a unit vector basis based on a given direction
%
% args:
% 		(x2,y2)   some point
% 		(x1,y1)   another point
%
% result:
% 		(Fx,Fy)   a unit vector perp to E
% 		(Ex,Ey)   a unit vector, aimed from E to F
%
/MakeBasis
	{
	CopyXX sub  neg  /dx exch def
	CopyYY sub  neg  /dy exch def
	pop pop pop pop
	
	% Compute normalization constant
	1.0
	dx dx mul   dy dy mul add sqrt  
	div
	/m exch def
	
	% Create basis vectors
	dx m mul
	dy m mul
	dy neg m mul
	dx m mul	
	}
		bind def





% Dot draws a solid circle to indicate line connections, etc
% args:
%		(x,y)  - location
%
/Dot
	{
	newpath
	2.5  0 360 arc   fill	
	}
		bind def




% ------------------------ Style Definitions -------------------------
%
% Each component has a set of parameters to tweak its size, style
% Each is named (use)(component)(modifier)
% where (use) is one of
% 		W for a width,  for parts with fixed orientation
% 		Y for a height, for parts with fixed orientation
% 		L for length along an axis, for parts that may be oriented any way
% 		W is also for width (crossways from axis) of reorientabls parts
% 		dY for a vertical spacing
% 		dX for a horizontal spacing
% 		R for a radius
% 		P for a proportion - a pure number, such as a ratio of two widths
% 		N for a integer number 
%		F for a feature flag - 0 or 1 to have or omit something
% 		A for an angle, degrees
%
% C programmers, especially those who code for Microsoft Windows,
% will recognize this as a form of "Hungarian Notation"
% All values are in the usual Postscript units where 72 = one inch.
%

% General style
/FOver  0   def         % how crossed lines jump over
/WLine  1.45   def         % width of lines in general
/WLineGaps 6.0 def

/SSign 5.75 def               % width & height of + sign, - sign


% Ground Style Params
/WGnd  0.25 pinch    def    % width of top bar
/HGnd  0.14 pinch    def
/NGnd  3          def    % number of horizontal bars, normally 3 or 4
/PGndBot  0.2 def    % width of bottom bar, as fraction of top bar




/RConnect  .06 inch def

% Arrowhead 
%  L is size of head along shaf direction, 
%  W is shaft to tip of wing  (half the head's width)
/LArrow  .16 pinch  def
/WArrow  .09 pinch  def


% Antenna Style Params
/WAnt  .33 pinch def
/HAnt  .38  pinch def
/LAntStem  0.3 pinch def


% Round component (signal source, meter, etc)
/LRound .25 pinch  def


% Resistor Style Params
/WRes  0.160 pinch  def
/LRes  0.40  pinch  def
/NResPeaks  3 def     % number of traingular peaks on each side


% Capacitor Style Params
/WCap  0.250 pinch def
/LCap  0.08  pinch def
/RCap  0.50  pinch def
/PCapBend  1.7  def  % curvature; > 1.0
/TCap  2.5  def
/XCapPlus  0.20 pinch def   % position of plus rel to top center
/YCapPlus 0.15 pinch def


% Diode Style Params
/WDiode 0.270 pinch  def
/LDiode 0.240 pinch  def
/TDiodeCath  3.4 def


% Battery Style Params
/WBattery .33 pinch  def
/WBatteryN  WBattery .44 mul def
/LBattery  .3 pinch  def
/TBatteryP  WLine def
/TBatteryN  WLine 1.6 mul def


% Coil Style Params
/WCoil  0.30 pinch def
/LCoil  0.57 pinch  def
/IronSep  .055 pinch  def    % (oops, non-Hungarian) sep. of two lines for Fe core

% Transformer Style Params
% note: dxTrfGap involves the parameter coilyy which is a bezier control
% point coordinate.   This does not coincide with the symbol as drawn.
/dxTrfLegs  .1 pinch def    % how far away from coil before cornering
/dxTrfGap   .07 pinch def   % approx. distance between coils 



% Crystal Style Params
/WCrystal  0.33 pinch def
/LCrystal  0.27 pinch def


% SPST Switch Style Params
/LSwi  0.33 pinch  def
/RSwiDot 2.5  def
/ASwi   25 def



/FQCircle   true  def      % want circles around transistors?
/TQCircle  2 def
/RQCircle  0.34 pinch def

% Bipolar Transistor Style Params
% default is to draw a circle around it
/WBip      0.24 pinch  def
/HBip      0.4 pinch  def
/TBipBase    3   def
/LBipBase    .40 pinch  def


% FET Transistor Style Params
/WFet  0.23 pinch  def 
/HFet  0.37 pinch  def
/TFetBase    3 def
/LFetBase    .46 pinch def

% Op Amp Style Params
/LOp   0.67 pinch  def    % from input side to output apex
/WOp   0.58 pinch  def    % between ends of input side
/SOp   0.24 pinch  def    % spacing between + and - inputs
/TOpLine  2 def          % thickness of line for triangle
/dXOpSigns .117 pinch def


/SLabel     11  def
/LabelFont  /Times-Roman findfont SLabel scalefont  def
/dyLabel    10.8 def







%-------------------------------- COMPONENTS -----------------


% All components have a subroutine to draw one component,
% and a Precalc that should be called once before drawing anything.
%
% Most parts take one or more positions -these are locations
% of line endpoints, not the endpoints of the actual symbol.
% This saves the trouble of having to specify precise endpoints
% compatible with the part's size.
% For example, for Gnd, we do not give the point at the center
% of the top bar, but the point where the ascending vertical 
% meets a horizontal line or some other component's connect point.

% All components are drawn assuming the caller has started a newpath,
% and will call stroke when done.  
% 




% Subroutine to set up a two-terminal part
%
% Most parts draw themselves between two given points, including
% arbitrary length lines to fill the distance between the points
% not taken up by the part body itself.
% This subroutine figures out the lengths of these lines,
% and also prepares the coordinate system so that
% the part can assume it'll be horizontally oriented,
% with the symbol endpoints at (0, 0)  and  (LPart, 0),
% and the current drawing point at (0,0) in that system.
%
% When done drawing, be sure to call Part2Finish
%
% args:
% 		L            length of part body
% 		(x2,y2)      end point
% 		(x1,y1)      start point
%
/Part2Setup
	{
	/partlen exch def
	
	gsave
	newpath

	% Find relative position of end connection
	/deltax  2 index 5 index sub  def
	/deltay  1 index 4 index sub  def
	
	% Change to the part's local coord sys
	% First, translate to starting connection
	pop	pop
	translate
	% Second, rotate so end connection is along transformed x' axis
	deltax dup mul  deltay dup mul add sqrt
	/dist exch def
	/c deltax dist div def
	/s deltay dist div def
	[ c  s  s neg  c   0  0 ]  concat



	% Now we're using a coord sys in which part appears along x'

	% Draw white fat line to create gaps at line crossovers
	1 setgray    % for testing, set this to 0.8 
	0 setlinecap
	WLineGaps setlinewidth
	WLineGaps 0 moveto
	dist WLineGaps sub   0 lineto
	stroke


	% Draw legs in black	
	0 setgray
	WLine setlinewidth
	/leglen   dist partlen sub  2 div  def
	0    0   moveto   leglen           0  lineto
	dist 0   moveto   dist leglen sub  0  lineto
	stroke

	% change coord system origin to one end of the part body
	leglen 0 translate 
	0 0 moveto   
	}
		bind def



/Part2Finish
	{
	grestore	
	
	}
		bind def


% FatWhiteLine is a utility to draw a fat white line
% between two points
% Used by InArrow and other parts that don't use Part2Setup
%
/FatWhiteLine
	{
	
	% Draw fat white line for crossover gaps
	4 copy    WLineGaps  
		{
		1 setgray    % temp. set to 0.5 for testing of white-gap bars
		0 setlinecap
		WLineGaps setlinewidth
	    moveto   lineto  stroke
		0 setgray
		WLine setlinewidth
		}
	if
	}
		bind def
		






% Draw a plus or minus sign.  Size is set by SSign
%
% args:
%		(x,y)    - center point of sign
%
/PlusSign
	{
	/h  SSign 2 div def
	exch h sub  exch   moveto
	SSign  0  rlineto
	h neg  dup  rmoveto
	0  SSign  rlineto
	stroke
	}
		bind def

/MinusSign
	{
	% draw the minus to be a tad longer than the bars of the + sign
	moveto
	SSign -.6 mul  0 rmoveto
	SSign 1.2 mul  0 rlineto
	stroke
	}
		bind def





% Gnd draws a ground symbol
%
% Args: 
%   (x,y)    - position of ground symbol, where it connects to line
% 	(x,y)    - attach point to circuit
%    
%
% Variables:
% 	gnddy  - vertical spacing between bars

/GndPrecalc
	{
	% computer vertical spacing
	/gnddy HGnd  NGnd 1 sub  div  neg  def

	% compute reduction of width per bar
	/gnddw WGnd WGnd PGndBot mul sub  NGnd 1 sub div  neg def
	}
		def
	
/Gnd 
	{
	2 copy     
	6 2 roll   
	Line
	newpath
	% save negated width into a variable
	/w WGnd neg def
	moveto
	1 1 NGnd
		{
		pop  % don't need loop counter
		w  2 div neg  0  rmoveto
		w             0  rlineto
		w  2 div neg  0  rmoveto
		0  gnddy  rmoveto
		/w w gnddw sub def
		} 
	for
	stroke
	} 
		bind def


/PtGnd  % Gnd that takes one point, usualy the end of a line or op amp input
	{
	2 copy Gnd
	}
		bind def


/EarthGnd
	{
	2 copy     
	6 2 roll   
	Line


	newpath
	
	moveto
	WGnd 2 div neg  0  rmoveto   % now at left end of horiz bar
	currentpoint   /y exch  def   /x exch def
	/dx WGnd  3 div  def
	/s  WGnd  -0.18 mul def
	x  y  moveto   WGnd  0  rlineto
	x                y  moveto     s  HGnd neg  rlineto
	x dx       add   y  moveto     s  HGnd neg  rlineto
	x dx 2 mul add   y  moveto     s  HGnd neg  rlineto
	x dx 3 mul add   y  moveto     s  HGnd neg  rlineto
	stroke

	}
		bind def




% Connect is just a little circle at the end of a line
% Works like antenna, out arrow, etc.
%
% args
% 		(x,y)  location of connect circle
%		(x,y)  end of line that attaches to circuit
%
		
/Connect 
	{
	4 copy  Line
	
	% Draw the circle
	
	newpath 
	WLine setlinewidth
	0 setgray
	RConnect  0 360  arc  gsave 1 setgray fill grestore stroke
	
	% Waste the final coord - it was already used by Line
	pop pop
	}
		bind def



% Arrow draws from first point all the way to 2nd point,
% ending with an outgoing arrow
% See also InArrow
%
% args
%		(x,y) of arrowhead
%		(x,y) attachment to circuit
%
/OutArrowPrecalc
	{
	}
		def


/OutArrow
	{
	% label positioning
	2 copy 
	WArrow  1.2 mul
	7 3 roll 
	
	4 copy
	MakeBasis
	WArrow mul  /Fy  exch def
	WArrow mul  /Fx  exch def
	LArrow mul  /Ey  exch def
	LArrow mul  /Ex  exch def
	newpath

	% Draw fat white line for crossover gaps
	4 copy    WLineGaps  ShrinkSeg
		{
		1 setgray    
		0 setlinecap
		WLineGaps setlinewidth
		  moveto   lineto  stroke
		}
	if
	

	0 setgray
	WLine setlinewidth
	
	% copy head point, for drawing
	2 copy 	moveto
	Ex  neg  Fx add
	Ey  neg  Fy add
	rlineto
	
	% again, for opposite side of arrowhead
	2 copy 	moveto
	Ex  neg  Fx sub
	Ey  neg  Fy sub
	rlineto
	
	% line from tail to head
	moveto	
	lineto
	stroke

	}
		bind def




/InArrowPrecalc
	{
	}
		def


				
/InArrow
	{
	% same as OutArrow except negate wings' lengthwise components
	
	% label positioning
	2 copy 
	WArrow 1.41 mul
	7 3 roll 
	
	4 copy
	MakeBasis
	WArrow mul  /Fy  exch def
	WArrow mul  /Fx  exch def
	LArrow mul  /Ey  exch def
	LArrow mul  /Ex  exch def
	newpath

	% Draw fat white line for crossover gaps
	4 copy    WLineGaps  ShrinkSeg
		{
		1 setgray    
		0 setlinecap
		WLineGaps setlinewidth
		  moveto   lineto  stroke
		}
	if
	

	0 setgray
	WLine setlinewidth
	
	% copy head point, for drawing
	2 copy 	moveto
	Ex     Fx add
	Ey     Fy add
	rlineto
	
	% again, for opposite side of arrowhead
	2 copy 	moveto
	Ex     Fx sub
	Ey     Fy sub
	rlineto
	
	% line from tail to head
	moveto	
	lineto
	stroke
	
	}
		bind def





/AntPrecalc
	{
	/antw2   WAnt 2 div  def
	}
		def

/Ant
	{
	newpath
	moveto	
	0  LAntStem  HAnt add  rlineto
	antw2 neg   0    rmoveto
	antw2      HAnt neg  rlineto
	antw2      HAnt      rlineto
	WAnt neg    0  rlineto
	stroke
	}
		bind def


% Line just draws a line between two points
%
% Args:
% 	(x,y)
% 	(x,y)

/LinePrecalc
	{
	% nothing
	}
		def

		
/Line
	{
	/LW currentlinewidth def     % is going to be used a lot

	% see if points are the same, and boogie on out of here if so

	4 copy 3 -1 roll  sub abs 3 1 roll sub abs add
	0 le
		{
		pop pop pop pop   % blow away the inputs
		}
	
		{
		newpath


		% draw a fatter, shorter white line to make crossover gaps
		% shorten the line by approx. 2*WLine at each end
		4 copy WLineGaps  ShrinkSeg
			{
			1 setgray
			WLineGaps   setlinewidth
			0 setlinecap
			moveto	lineto	stroke
			}
		if

		% draw the complete black line, normal thickness, over the white bed
		0 setgray
		1 setlinecap
		WLine setlinewidth	
		moveto 	lineto	stroke
		LW setlinewidth
		}
	
	ifelse
	}
		def



/Blank
	{
	LRes
	Part2Setup	
	% nothing
	Part2Finish	
	}
		bind def



% Resistor
% args:
% 	(x,y)
% 	(x,y)
% 	nlabels  - number of labels, normally two or three
%   label1   - conventionally something like "R4"
%   label2   - conventionally the ohms
%   label3   - conventionally the wattage (optional)
%
% 
/ResPrecalc
	{
	/resw2  WRes 2 div def
	/resd   LRes NResPeaks div 4 div  def
	}
		def

/Res
	{
	% label locating === experimental!
	4 copy    MidPoint
	WRes
	7  3 roll  % puts label location info at the bottom of stack
	
	LRes
	Part2Setup	
	NResPeaks 
		{
		resd resw2 rlineto
		resd dup add  WRes neg rlineto
		resd resw2 rlineto
		}
	repeat
	stroke
	Part2Finish	
	
	% deposit_bounds
	}
		bind def




/VarResPrecalc
	{
	ResPrecalc
	}
		def


/VarRes    % Variable Resistor - two terminal
	{
	% label locating === experimental!
	4 copy MidPoint	
	WRes 1.2 mul
	7  3 roll  % puts label location info at the bottom of stack


	LRes
	Part2Setup	
	NResPeaks 
		{
		resd resw2 rlineto
		resd dup add  WRes neg rlineto
		resd resw2 rlineto
		}
	repeat
	
	% draw arrow
	   1  -8.0   moveto
	LRes 1 sub   8.0 lineto
	currentpoint currentpoint
	moveto   -1.5 -4 rlineto
	moveto   -4 -1.5 rlineto
	
	stroke 
	Part2Finish	
	}
		bind def





/CapPrecalc
	{
	/capw2  WCap  2 div  def
	}
		def


/Cap
	{
	% label locating data
	4 copy MidPoint	
	WCap  .55 mul
	7  3 roll  % puts label location info at the bottom of stack

	LCap
	Part2Setup

	TCap setlinewidth
	0 setlinecap
	0  capw2  rmoveto
	0  WCap neg  rlineto
	stroke

	LCap  PCapBend mul  capw2       moveto
	LCap   capw2 2 div
	LCap   capw2 2  neg div
	LCap  PCapBend mul   capw2 neg
	curveto
	stroke 
	
	Part2Finish
	}
		bind def


/ElectroCap
	{
	% label locating === experimental!
	4 copy MidPoint	
	WCap  1.1 mul
	7  3 roll  % puts label location info at the bottom of stack

	% copy of code from Cap (can't just call it; need to omit Part2Finish)
	LCap
	Part2Setup

	TCap setlinewidth
	0 setlinecap
	0  capw2  rmoveto
	0  WCap neg  rlineto
	stroke

	LCap  PCapBend mul  capw2       moveto
	LCap   capw2 2 div
	LCap   capw2 2  neg div
	LCap  PCapBend mul   capw2 neg
	curveto
	gsave  stroke  grestore 
	

	% new code --  Draw the plus sign
	WLine .8 mul setlinewidth               % EXP STYLE MOD 2009
	SSign 1.0 mul neg   WCap .6 mul    PlusSign 
	WLine setlinewidth

% Tail end of code stolen from Cap
	Part2Finish
	}
		bind def



/VarCap
	{
	% label locating === experimental!
	4 copy MidPoint	
	WCap 1.4 mul
	7  3 roll  % puts label location info at the bottom of stack

	LCap
	Part2Setup

	TCap setlinewidth
	0 setlinecap
	0  capw2  rmoveto
	0  WCap neg  rlineto
	stroke

	LCap  PCapBend mul  capw2       moveto
	LCap   capw2 2 div
	LCap   capw2 2  neg div
	LCap  PCapBend mul   capw2 neg
	curveto
	gsave  stroke  grestore 
	
	% draw arrow
	WLine setlinewidth
	 -9  -10.0 moveto
	20  10.0 lineto
	currentpoint currentpoint
	moveto   -4 -8 rlineto
	moveto   -8 -2 rlineto
	stroke

	Part2Finish
	}
		bind def




/CoilPrecalc
	{
	/coilsx  LCoil 0.13 mul def
	/coilbx  LCoil  coilsx 3 mul  add  4 div  def
	/coilyy  WCoil  0.7 mul  def
	/coilbb  coilyy .4 mul def
	}
		def
		
/CoilBigLoop
	{
	% already at current point; need to end up at (+coilbx,0)
	currentpoint translate	
	0 0 moveto
	0 coilyy  
	coilbx coilyy
	coilbx 0
	curveto
	}
		bind def
		
/CoilSmallLoop
	{
	currentpoint translate	
	0  0  moveto
	0  coilbb neg
	coilsx neg  coilbb neg
	coilsx neg  0 
	curveto
	}
		bind def



% Coil with or without iron
%
% args:
%		iron     t/f
%		(x,y)
%		(x,y)
%
/Coil
	{
	/iron exch def
	
	% label locating === experimental!
	4 copy MidPoint	
	WCoil
	7  3 roll  % puts label location info at the bottom of stack

	LCoil
	Part2Setup

	gsave
	iron 
		{
		0   coilyy 1.05 mul   moveto  currentpoint  
		LCoil 0  rlineto  
		moveto   0  IronSep  rmoveto   LCoil 0  rlineto
		stroke
		}
	if
	grestore

	CoilBigLoop
	3 {	CoilSmallLoop	CoilBigLoop } repeat
	stroke

			
	Part2Finish
	}
		bind def



% VTransformer  - transformer with vertical coils
% HTransformer  - transformer with horizontal coils
%
% args
%		iron      t/f
%		n right coil  - number of loops in right coil
%		n left coil  -   number of loops in left coil
%		(x,y) right coil terminal #2
%		(x,y) right terminal #1
%		(x,y) left  terminal #2
%		(x,y) left  terminal #1
%
/VTransformer
	{
	/iron exch def
	/nloopsr  exch def
	/nloopsl  exch def
	
	/ray exch def
	/rax exch def
	/rby exch def
	/rbx exch def
	/lay exch def
	/lax exch def
	/lby exch def
	/lbx exch def
	
	% Find region bounded by the four points
	% X coords: find rightmost x of left coil, and leftmost x of right coil
	% Similar for Y coords
	/lix   lax lbx largest   def
	/rix   rax rbx smallest  def
	/tiy  ray rby largest  lay lby largest  smallest  def   % top inner y
	/biy  ray rby smallest lay lby smallest largest   def   % bottom inner y

	% This sets the location of the transformer center
	/centerx  lix rix add 2 div  def
	/centery  tiy biy add 2 div def
	
	% compute coil lengths
	/llen   coilsx neg  nloopsl 1 sub mul  coilbx nloopsl mul add   def
	/rlen   coilsx neg  nloopsr 1 sub mul  coilbx nloopsr mul add   def

	% compute y coords of coil ends 
	/rcoilybottom   centery rlen 2 div sub	 def
	/rcoilytop      centery rlen 2 div add	 def
	/lcoilybottom   centery llen 2 div sub    def
	/lcoilytop      centery llen 2 div add    def


	% Determine x coords for coils - Right Coil, Left Coil
	% This is position of point where loops attach to lines
	% Must allow for size of big loops and also iron core
	% (the parameter coilyy is being used in the x coord calc)
	/dy coilyy   iron { IronSep .5 mul add 1.1}{0.95}  ifelse mul  def
	/lcoilx	 centerx dy  sub def
	/rcoilx	 centerx dy  add def

% testing:
%	centerx centery  redmarker
%	centerx  IronSep 2 div sub  centery barlen 2 div add  bluemarker

	iron 
		{
		% go to top of left line of core bars, then draw each line
		/barlen  llen rlen largest  def
		centerx  IronSep 2 div sub  centery barlen 2 div add  moveto
		0  barlen neg  rlineto
		IronSep 0 rmoveto
		0 barlen  rlineto
		stroke
		}
	if	
	
	% draw the left coil
	% remember, BigLoop messes with the current transform
	gsave
	lcoilx  lcoilytop translate
	-90 rotate
	0 0 moveto
	CoilBigLoop
	nloopsl 1 sub  { CoilSmallLoop  CoilBigLoop } repeat
	stroke
	grestore
	
	% draw the right coil
	%
	gsave
	rcoilx  rcoilybottom  translate
	90  rotate
	0 0 moveto
	CoilBigLoop
	nloopsr 1 sub  { CoilSmallLoop  CoilBigLoop } repeat
	stroke
	grestore
	
	
	% connect lines to appropriate terminals
	% connect top of left coil to higher  of the two left terminals
	% and bottom to the lower.
	lay lby gt  { lbx lby lax lay } { lax lay lbx lby } ifelse
	lcoilx  lcoilytop  lcoilx  3 index Line  
	lcoilx 1 index  Line
	lcoilx  lcoilybottom  lcoilx  3 index Line  
	lcoilx 1 index  Line
	
	% same for right coil...
	ray rby gt  { rbx rby rax ray } { rax ray rbx rby } ifelse
	rcoilx  rcoilytop  rcoilx  3 index Line  
	rcoilx 1 index  Line
	rcoilx  rcoilybottom  rcoilx  3 index Line  
	rcoilx 1 index  Line
	
	% deposit label positioning info
	% assumes that label will go above or below
	centerx centery  
	rlen llen largest .6 mul   % longest coil sets label displacement
	}
		bind def



/HTransformer
	{
	% if we turn our heads 90 deg, then it's a vertical transformer
	% Actually, we'll leave out the  - sign
	% all we have to do is exchange  x <--> y  and make
	% the corresponding change in the transform matrix
	
	% move coords up to top of stack 
	11 3  roll 
	
	% swap x<->y   
	4 { } repeat
	
	gsave
	[ 0 1 1 0 0 0 ] concat
	VTransformer
	
	% undo transform
	grestore
	
	% label positioning info needs to be transformed x <--> y
	
	}
		bind def 


/CrystalPrecalc
	{
	/crysx1 LCrystal .27 mul   def
	/crysx2 LCrystal crysx1 sub def
	/crysy1  WCrystal .7 mul  .5 mul def
	/crysy2  crysy1 neg  def
	}
		def


/Crystal
	{
	% label locating === experimental!
	4 copy MidPoint	
	WCrystal .7 mul
	7  3 roll  % puts label location info at the bottom of stack

	LCrystal
	Part2Setup

	0  WCrystal 2 div neg  moveto
	0  WCrystal  rlineto
	LCrystal  WCrystal 2 div neg  moveto
	0  WCrystal  rlineto
	
	crysx1 crysy1 moveto
	crysx2 crysy1 lineto
	crysx2 crysy2 lineto
	crysx1 crysy2 lineto
	crysx1 crysy1 lineto
	
	stroke
		
	Part2Finish
	}
		bind def


/SwitchPrecalc
	{
	/swiopendx  ASwi  cos  LSwi mul  def
	/swiopendy  ASwi  sin  LSwi mul  def
	/swicdy   RSwiDot 0.4 mul def    % tweaks how lever attaches to dot
	}
		bind def


/Switch
% args:  
% 		state    1=OPEN,  0=CLOSED, -1=OPEN ON OTHER SIDE 
% 		(x,y)   - connect pt, hinge end
% 		(x,y)   - connect pt 
	{
	/mystate exch def

	% label locating === experimental!
	4 copy MidPoint	
	WRes   % dumb guess; no WSwi
	7  3 roll  % puts label location info at the bottom of stack

	LSwi
	Part2Setup
	
	% draw two dots
	0   0   RSwiDot  0 360 arc   fill	
	LSwi 0  RSwiDot  0 360 arc   fill	
	
	% draw the lever
	0 swicdy moveto
	mystate 0 eq
		{ swiopendx swiopendy rlineto }
		{ LSwi 0  rlineto }
	ifelse
	stroke
	
	Part2Finish
	
	currentdict /mystate undef
	}
		bind def



/BipPrecalc
	{
	/bipady LBipBase .25 mul  def
	}
		def
		

% Bipolar transistors
% args:
%      (x,y)  of collector
%      (x,y)  of base
%      (x,y)  of emitter
%
% Must have Cx = Ex  and By between Ey and Cy
% Transistor may be facing left or right
%
/BipolarStuff   % private routine - use BipNPN or BipPNP
	{
	/Cy  exch def
	/Cx  exch def
	/By  exch def
	/Bx  exch def
	/Ey  exch def
	/Ex  exch def

	% Calculate x coord of base
	/BBx Ex WBip   Ex Bx lt { add } { sub }  ifelse   def
	
	% calculate attachment points (just y coord) of E, C to base bar
	/ACy By  bipady   Cy By gt { add } { sub }  ifelse  def
	/AEy By  bipady   Ey By lt { sub } { add }  ifelse  def
	
	% calculate knee points for E, C  (just y coord)
	/KCy  By   HBip 2 div  Cy By gt { add } { sub } ifelse  def
	/KEy  By   HBip 2 div  Ey By lt { sub } { add } ifelse  def


	newpath
	
	% Draw fat white lines
	Ex Ey Cx Cy   WLineGaps ShrinkSeg
		{
		WLineGaps setlinewidth
		1 setgray
		0 setlinecap
		moveto  lineto
		}
	if
	
	Bx By BBx  By  WLineGaps ShrinkSeg
		{
		moveto lineto
		stroke
		WLine setlinewidth
		0 setgray
		}
	if	
	
	% Draw base bar
	TBipBase  setlinewidth
	BBx   By LBipBase 2 div sub  moveto
	0 LBipBase  rlineto
	stroke
	
	% Draw base terminal 
	WLine setlinewidth
	BBx  By  moveto  Bx By lineto  
	stroke

	% Draw collector
	BBx  ACy   moveto
	Cx   KCy  lineto
	Cx    Cy  lineto    
	stroke
	
	% Draw emitter   (but no arrow)
	BBx  AEy  moveto
	Ex   KEy lineto
	Ex    Ey  lineto
	stroke

	% draw circle
	FQCircle 
		{	
		BBx Ex add 2 div   By 
		TQCircle  setlinewidth
		RQCircle 
		0 360 arc stroke
		}
	if
	
	% deposit label location info
	BBx By RQCircle 1.52 mul
	}
		bind def


/BipNPN
	{
	BipolarStuff

	% Draw emitter arrow
	WLine setlinewidth
	/dx  WBip .6 mul   Bx Ex lt { neg } { } ifelse   def
	/dy  HBip .4 mul   Ey Cy lt { }  { neg } ifelse  def
	
	Ex  KEy   moveto   dx 1.23  mul    dy .215 mul  neg    rlineto
	Ex  KEy   moveto   dx  .61 mul    dy  1.05 mul       rlineto
	stroke
	}
		bind def


/BipPNP
	{
	BipolarStuff

	% Draw emitter arrow
	WLine setlinewidth
	/dx  WBip .6 mul   Bx Ex lt  { }   { neg } ifelse   def
	/dy  HBip .4 mul   Ey Cy lt { neg }  { }   ifelse  def
	
	BBx  AEy   moveto   dx 1.4 mul  0   rlineto
	BBx  AEy   moveto   dx .9 mul   dy .75 mul        rlineto
	stroke
	}
		bind def




% FET - Field Effect Transistor
%
% args
% 		(x,y)  for source
%		(x,y)  for gate
%		(x,y)  for drain

/FetPrecalc
	{
	/fetady LBipBase .4 mul  def
	}
		def


/FetStuff
	{
	% code stolen from Bipolar - keep the same names E,B,C
	/Cy  exch def
	/Cx  exch def
	/By  exch def
	/Bx  exch def
	/Ey  exch def
	/Ex  exch def

	% Calculate x coord of bar
	/BBx Ex WBip .7 mul  Ex Bx lt { add } { sub }  ifelse   def
	
	% calculate attachment points (just y coord) of E, C to base bar
	/ACy By  fetady   Cy By gt { add } { sub }  ifelse  def
	/AEy By  fetady   Ey By lt { sub } { add }  ifelse  def
	
	% calculate knee points for E, C  (just y coord)
	% = same as attachment points y coords; same x as Cx or Ex
	/KCy  ACy def
	/KEy  AEy def

	newpath
	
	% Draw fat white lines
	WLineGaps setlinewidth
	1 setgray
	0 setlinecap
	Ex Ey Cx Cy   WLineGaps ShrinkSeg
		{
		moveto  lineto stroke
		}
	if
	
	Bx By BBx  By  WLineGaps ShrinkSeg
		{
		moveto lineto stroke
		}
	if
	WLine setlinewidth
	0 setgray

	
	% Draw main bar
	TFetBase  setlinewidth
	BBx   By LFetBase 2 div sub  moveto
	0 LFetBase  rlineto
	stroke
	
	% Draw gate terminal 
	WLine setlinewidth
	BBx  By  moveto  Bx By lineto  
	stroke

	% Draw collector
	BBx  ACy   moveto
	Cx   KCy  lineto
	Cx    Cy  lineto    
	stroke
	
	% Draw emitter
	BBx  AEy  moveto
	Ex   KEy lineto
	Ex    Ey  lineto
	stroke

	% draw circle
	FQCircle 
		{	
		TQCircle  setlinewidth
		BBx  By 
		RQCircle 
		0 360 arc stroke
		}
	if

	% deposit label location info
	BBx By RQCircle 1.2 mul
	}
		bind def
		

/FetN
	{
	FetStuff
	
	% Draw N-Channel arrow (away from substrate)
	/dx  WFet .8 mul    Bx Ex lt { neg }  if   def
	/dy  dx abs .45 mul  def
	BBx  By moveto  currentpoint
	dx  dy      rlineto
	moveto
	dx  dy neg  rlineto
	stroke
	}
		bind def
		
		
/FetP
	{
	FetStuff
	
	% Draw P-channel arrow (into substrate)
	/dx  WFet .7 mul    Bx Ex lt { neg }  if   def
	/dy  dx abs .75 mul  def
	BBx dx 1.6 mul  add By moveto 	currentpoint
	dx neg dy      rlineto
	moveto
	dx neg  dy neg  rlineto
	stroke
	}
		bind def



% Op Amp
% Either + or - may be on top.
% Depending on coords, op amp may appear in any of eight orientation
% facing one of four directions, and +/- input interchange
% OpAmp does this by comparing coords and then calling one 
% of the  four functions OpAmpRt, OpAmpLf, OpAmpTop OpAmpBot.
% These functions may be called directly.
%
% args:
%		(x,y)   output 
% 		(x,y)   + input
% 		(x,y)   - input
%
/OpAmpPrecalc
	{
	}
		def
		
/OpAmpRight
	{
	/Oy  exch def
	/Ox  exch def
	/Py  exch def
	/Px  exch def
	/My  exch def
	/Mx  exch def
	
	newpath
	WLine setlinewidth
	0 setlinecap
	
	% Is the - input above the +?
	/mtop  My Py gt  def
	
	% How much room along x axis to fit the op amp into?
	/roomx  Ox    Mx Px gt { Mx } { Px } ifelse   sub  def

	% Figure out where the apex of the triangle will be
	/apexx  Ox  roomx  LOp sub  2 div  sub def
	/apexy  Oy  def
	
	% Figure out where the inputs connect to the triangle
	/basex apexx  LOp sub  def
	/miy  apexy SOp 2 div   mtop { add } { sub } ifelse  def
	/piy  apexy SOp 2 div   mtop { sub } { add } ifelse  def
	
	% Draw lead to + input, and + sign
	basex  piy    Px  piy Line
	Px     piy    Px  Py  Line
	WLine setlinewidth
	basex dXOpSigns add   piy  PlusSign
	
	% Draw lead to - input, and - sign
	basex miy    Mx  miy Line
	Mx    miy    Mx  My   Line
	WLine setlinewidth
	basex dXOpSigns add   miy  MinusSign
	
	% Draw lead to output
	apexx  apexy
	Ox Oy Line
	stroke
	
	% Draw triangle
	/miy  apexy  WOp 2 div   sub  def
	/piy  apexy  WOp 2 div   add  def
	TOpLine setlinewidth
	apexx apexy moveto
	basex miy lineto
	basex piy lineto
	closepath
	stroke
	
	
	WLine  setlinewidth
	
	% label to go near apex, for lack of brain power to do better
	apexx .6 mul basex .4 mul add  apexy
	WOp .6 mul

	currentdict  /miy undef
	currentdict  /piy undef
	currentdict  /apexx undef
	currentdict  /apexy undef
	}
		bind def


/OpAmpLeft
	{
	% Copied from OpAmpRight, with certain x-coord calculations reversed
	
	/Oy  exch def
	/Ox  exch def
	/Py  exch def
	/Px  exch def
	/My  exch def
	/Mx  exch def
	
	newpath
	WLine setlinewidth
	0 setlinecap
	
	% Is the - input above the +?
	/mtop  My Py gt  def
	
	
	% How much room along x axis to fit the op amp into?
	/roomx  Ox    Mx Px lt { Mx } { Px } ifelse   sub  neg  def %left: neg

	% Figure out where the apex of the triangle will be
	/apexx  Ox  roomx  LOp sub  2 div  add def   %left: add
	/apexy  Oy  def
	
	% Figure out where the inputs connect to the triangle
	/basex apexx  LOp add  def   %left: add
	/miy  apexy SOp 2 div   mtop { add } { sub } ifelse  def
	/piy  apexy SOp 2 div   mtop { sub } { add } ifelse  def
	
	% Draw lead to + input, and + sign
	basex  piy    Px  piy Line
	Px     piy    Px  Py  Line
	WLine setlinewidth
	basex dXOpSigns sub   piy  PlusSign  %left: sub
	
	% Draw lead to - input, and - sign
	basex miy    Mx  miy Line
	Mx    miy    Mx  My  Line
	WLine setlinewidth
	basex dXOpSigns sub   miy  MinusSign  % left: sub
	
	% Draw lead to output
	apexx  apexy
	Ox Oy Line
	stroke
	
	% Draw triangle
	/miy  apexy  WOp 2 div   sub  def  %left: unchanged; these are y coords
	/piy  apexy  WOp 2 div   add  def
	TOpLine setlinewidth
	apexx apexy moveto
	basex miy lineto
	basex piy lineto
	closepath
	stroke
	
	
	WLine  setlinewidth
	
	% label to go near apex, for lack of brain power to do better
	apexx .6 mul basex .4 mul add  apexy
	WOp .6 mul

	currentdict  /miy undef
	currentdict  /piy undef
	currentdict  /apexx undef
	currentdict  /apexy undef
	}
		bind def



% Battery
/BatteryPrecalc
	{
	/wbat2   WBattery  2 div  neg def
	/wbatn2  WBatteryN 2 div  neg def
	}
		def

/Battery
	{
	% label locating === experimental!
	4 copy MidPoint	
	WBattery .7 mul
	7  3 roll  % puts label location info at the bottom of stack

	LBattery
	Part2Setup
	
	currentlinewidth
	currentlinecap
	0 setlinecap
	TBatteryP setlinewidth
	0                wbat2  moveto    0 WBattery rlineto
	LBattery .67 mul  wbat2  moveto    0 WBattery rlineto
	stroke
	TBatteryN setlinewidth
	LBattery .33 mul  wbatn2 moveto    0 WBatteryN rlineto
	LBattery .99 mul  wbatn2 moveto    0 WBatteryN rlineto
	stroke
	setlinecap  % restore original pen style
	setlinewidth
	
	SSign 1.20 mul neg   wbat2 1.22 mul  PlusSign 
	
	Part2Finish	
	}
		bind def


% Diode 
%
% args
%		(x,y)  anode
%		(x,y)  cathode
%
/DiodePrecalc
	{
	/diodew2  WDiode 2 div  def
	}
		def


/Diode
	{
	% label locating === experimental!
	4 copy MidPoint	
	WDiode .8 mul
	7  3 roll  % puts label location info at the bottom of stack

	LDiode
	Part2Setup
	
	% cathode
	currentlinecap
	currentlinewidth
	TDiodeCath setlinewidth
	0 setlinecap
	0  diodew2  rmoveto
	0  WDiode neg  rlineto
	stroke
	setlinewidth
	setlinecap

	% triangle
	0 TDiodeCath 4 div add  0 moveto
	LDiode diodew2 rlineto
	0  WDiode neg  rlineto
	closepath
	fill

	Part2Finish
	}
		bind def


/Zener
	{
	% label locating === experimental!
	4 copy MidPoint	
	WDiode
	7  3 roll  % puts label location info at the bottom of stack

	LDiode
	Part2Setup
	
	% cathode
	currentlinecap
	currentlinewidth
	TDiodeCath setlinewidth
	2 setlinecap
	
	diodew2 -.6 mul   diodew2 1.2 mul  rmoveto
	0  diodew2  lineto
	0  diodew2 neg  lineto
	diodew2  .6 mul   diodew2 -1.2 mul  lineto
	stroke
	setlinewidth
	setlinecap

	% triangle
	0 TDiodeCath 4 div add  0 moveto
	LDiode diodew2 rlineto
	0  WDiode neg  rlineto
	closepath
	fill

	Part2Finish
	}
		bind def



/Tunnel
	{
	% label locating === experimental!
	4 copy MidPoint	
	WDiode
	7  3 roll  % puts label location info at the bottom of stack

	LDiode
	Part2Setup
	
	% cathode
	currentlinecap
	currentlinewidth
	TDiodeCath setlinewidth
	0 setlinecap
	0  diodew2  rmoveto
	0  WDiode neg  rlineto
	stroke
	setlinewidth
	setlinecap

	% round body
	LDiode 2 div  TDiodeCath 2 div  add  0    LDiode 2 div  0 360  arc
	fill

	Part2Finish
	}
		bind def


/LED
	{
	% label locating === experimental!
	4 copy MidPoint	
	WDiode 1.0 mul
	7  3 roll  % puts label location info at the bottom of stack

	LDiode
	Part2Setup
	
	% cathode
	currentlinecap
	currentlinewidth
%	TDiodeCath setlinewidth
	0 setlinecap
	0  diodew2  rmoveto
	0  WDiode neg  rlineto
	stroke
	setlinewidth
	setlinecap

	% triangle
	0 TDiodeCath 4 div add  0 moveto
	LDiode diodew2 rlineto
	0  WDiode neg  rlineto
	closepath
	stroke
	
	%LDiode 2 div  0 LDiode 1.05 mul 0 360 arc stroke

	Part2Finish
	}
		bind def


/EmptyRound
% just an empty circle with two terminals, 
% used as start of a meter, signal source, etc.
% Use as an example.   
	{
	LRound 2 mul
	Part2Setup
	newpath
	LRound  0     LRound     0 360 arc
	stroke
	Part2Finish
	}
		def



/VoltSourcePrecalc
	{
	}
		def
		

/VoltSource
% args:
% 		(x,y) 	'+' end
% 		(x,y) 	'-' end
	{
	% label locating === experimental!
	4 copy MidPoint	
	LRound 1.2 mul
	7  3 roll  % puts label location info at the bottom of stack

	LRound 2 mul
	Part2Setup
	newpath
	LRound  0     LRound     0 360 arc
	
	SSign 1.1 mul         neg   SSign 1.3 mul  PlusSign  
	SSign 3.1 mul  LRound add   SSign 1.3 mul  MinusSign 
	stroke
	Part2Finish
	}
		bind def



/SineSourcePrecalc
	{
	/RSine  LRound 0.32 mul  def
	}
		bind def
		

/SineSource
%
% 		(x,y)
% 		(x,y)
	{

	% label locating === experimental!
	4 copy MidPoint	
	LRound 1.15 mul
	7  3 roll  % puts label location info at the bottom of stack

	LRound 2 mul
	Part2Setup
	newpath
	LRound  0     LRound     0 360 arc
	
	% Draw the sine wave
	% move to center of  circle
	LRound neg  0  rmoveto
	% remember this place
	currentpoint
	currentpoint
	% draw right half of sine as a bottom half of a circle
	exch RSine add exch   RSine 180 360 arc
	stroke  % to avoid initial line to this next arc
	exch RSine sub exch   RSine 0   180 arc
	
	stroke
	Part2Finish
	}
		bind def





% Box just draws a box, no terminals
% it produces label positioning info like other parts
% The distance is always zero, however, 
% assuming PartLabelCenter will be used.
%
%
% args (unusual order)
%		
%		xright
%		xleft
%		ybot
%		ytop
%		
% output
%				
%
/Box
	{
	TOpLine setlinewidth
	0 setgray
	newpath
	1 index  4 index moveto
	dup  4 index lineto
	dup 3 index lineto
	1 index 3 index lineto
	closepath
	gsave
	1 setgray
	fill
	grestore
	0 setgray
	stroke
	add 2 div 3 1 roll add 2 div
	0
	}
		bind def









% Label (in all variations) is for all the text labels
% just floating around nowhere, or labels for parts.
% For LabelTL, the given position is the upper left corner of the text.
%
% All the label positions are:
%   first letter:   T=top, M=middle, B=bottom  
%   second letter:  L=left, C=center, R=right 
%   All nine combinations are defined.
%   
% args:
% 		(xc,yc)     
%       [ line, line, ... ]
%
/LabelTL
	{
	LabelFont setfont
	moveto 
	0 dyLabel neg 2 add rmoveto
		{
		currentpoint
		3 -1 roll   % bring Nth string to top, over saved point
		show
		moveto  0 dyLabel neg  rmoveto
		}
	forall
	}
		bind def



		
/LabelBL		
	{
	% Measure height of the text 
	2 index    % copy the text list 
    length      % get the number of text lines
	dyLabel mul  % leaves height of text block on top of stack	
	
	% move up by altering the (x,y) already on the stack
	add
	% Let someone else to the grunt work
	% because we, the beautiful and strong, must exploit the working class
	LabelTL
	}
		bind def

/LabelML
	{
	% Measure height of the text 
	2 index    % copy the text list
	length
	dyLabel mul  % leaves height of text block on top of stack	
	
	% move halfway there
	2 div add
	LabelTL
	}
		bind def




/LabelTR
	{
	LabelFont setfont
	moveto 
	0 dyLabel neg 2 add rmoveto
		{
		currentpoint
		3 -1 roll   % bring Nth string to top, over saved point
		dup  stringwidth  pop neg 0  rmoveto
		show
		moveto  0 dyLabel neg  rmoveto
		}
	forall
	}
		bind def

/LabelMR
	{
	% Measure height of the text 
	2 index    % copy the text list
	length
	dyLabel mul  % leaves height of text block on top of stack	
	
	% move halfway there
	2 div add
	LabelTR
	}
		bind def

/LabelBR
	{
	% Steal code from LabelTL but call LabelTR instead
	% Measure height of the text 
	2 index    % copy the text list
	length
	dyLabel mul  % leaves height of text block on top of stack	
	
	% move up by altering the (x,y) already on the stack
	add
	LabelTR
	}
		bind def


% For horizontal centering, do same as right-side alignment but 
% but adjust only half-way.
% note that lines are centered individually, the whole set
% is not left or right justified
/LabelTC
	{
	LabelFont setfont
	moveto 
	0 dyLabel neg 2 add rmoveto
		{
		currentpoint
		3 -1 roll   % bring Nth string to top, over saved point
		
		dup  stringwidth  pop  neg 2 div  0  rmoveto
		show
		moveto  0 dyLabel neg  rmoveto
		}
	forall
	}
		bind def

/LabelMC
	{
	% Measure height of the text 
	2 index    % copy the text list
	length
	dyLabel mul  % leaves height of text block on top of stack	
	
	% move halfway there
	2 div add
	LabelTC
	}
		bind def
				
/LabelBC
	{
	% Steal code from LabelTL but call LabelTC instead
	% Measure height of the text 
	2 index    % copy the text list
	length
	dyLabel mul  % leaves height of text block on top of stack	
	
	% move up by altering the (x,y) already on the stack
	add
	LabelTC
	}
		bind def





% Movement operators for use with PartLabel* routines				
/u  { add } bind def
/d  { sub } bind def
/r  { 3 -1 roll  add exch  } bind def
/l  { 3 -1 roll exch sub exch } bind def


% PartLabelX where X is U, D, L or R, draws a label
% in relation to a part.
% Every part leaves a description of its location on the stack.
% args:
%		size                 = safe distance from part
% 		y                    = part location y
%		x                    = part location x
%		[ line, line ... ]   = label text
%
% Each PartLabelX applies one of the movement operators r,l,u,d
% and then calls one of the LabelXX procedures
%
/PartLabelAbove  { u LabelBC }  bind def
/PartLabelBelow  { d LabelTC }  bind def
/PartLabelLeft   { l LabelMR }  bind def
/PartLabelRight  { r LabelML }  bind def
/PartLabelLowerRight  { dup  4 1 roll r   3 2 roll d  LabelML }  bind def  % new 2009

% Centered part label is good for hollow parts like VoltSource, diode bridge, etc.
/PartLabelCenter { pop LabelMC }  bind def



% NoLabel takes same args as the PartLabels, but draws nothing.
% Should be used after drawing any part for which there's no label
%
/NoPartLabel
	{
	pop
	pop pop
	}
		bind def


%%script

% Call all Precalc routines
GndPrecalc
AntPrecalc
LinePrecalc
SwitchPrecalc
ResPrecalc
VarResPrecalc
CapPrecalc
CoilPrecalc
CrystalPrecalc
DiodePrecalc
SineSourcePrecalc
BipPrecalc
FetPrecalc
BatteryPrecalc
InArrowPrecalc
OutArrowPrecalc


% landscape layout
8.5 inch 0 translate  90 rotate


% pixelizing errors can be minimized with this tweak:
.0001 .01 translate  .002 rotate


2 setlinewidth
1 setlinejoin
1 setlinecap
0 setgray

